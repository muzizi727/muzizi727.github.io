<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java中的字符串</title>
    <link href="/2022/09/12/Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/09/12/Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中的字符串"><a href="#Java中的字符串" class="headerlink" title="Java中的字符串"></a>Java中的字符串</h1><p>Java提供了<code>String</code>、<code>StringBuffer</code>和<code>StringBuilder</code>类来封装字符串，并提供了一系列操作字符串对象的方法。它们的相同点都是用来封装字符串；并且都实现了<code>CharSequence</code>接口。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><code>String</code>类的<code>value</code>数组被声明为<code>final</code>，这意味着<code>value</code>数组初始化之后不能再引用其他数组，并且<code>String</code>内部没有改变<code>value</code>数组的方法，因此可以保证<code>String</code>不可变，同时保证线程安全。<code>String</code>类被声明为<code>final</code>，因此不可被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：</strong>不可变的意思是每次更改都会产生新的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <br>s += <span class="hljs-string">&quot;b&quot;</span>;<br></code></pre></td></tr></table></figure><p>以上代码会线程一个字符串”a”对象，并且s指向该对象。然后再生成一个字符串”ab”对象，把s的指向地址改为”ab”对象。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><code>StringBuffer</code>为字符串变量（线程安全），如果要频繁的对字符串内容进行修改，处于效率考虑最好使用可<code>StringBuffer</code>，如果想转成<code>String</code>类型，可以调用<code>StringBuffer.toString()</code>方法。</p><p><code>StringBuffer</code>上的主要操作是<code>append</code>和<code>insert</code>方法，可重载这些方法以接受任意类型的数据。每个方法都能有效的将给定的数据转换成字符串，然后将该字符串的字符添加或者插入到字符串缓冲区中。</p><ul><li><code>append</code>方法始终将这些字符添加到缓冲区的末端</li><li><code>insert</code>方法则在指定的位置添加字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//生成字符串abc</span><br>    s.append(<span class="hljs-string">&quot;e&quot;</span>); <span class="hljs-comment">//abce</span><br>    s.insert(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;d&quot;</span>);<span class="hljs-comment">//abcde</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p><code>StringBuilder</code>字符串变量（非线程安全），JDK5.0新增，此类提供一个与<code>StringBuffer</code>兼容的API，但不保证同步。</p><p>在单线程的情况下使用较普遍。</p><p>在大部分情况下<code>StringBuilder &gt; StringBuffer</code>。这主要是因为前者不需要考虑线程安全。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>三者区别：</p><ul><li><code>String</code>不可变字符串，线程安全</li><li><code>StringBuffer</code>可变的字符串，线程安全，方法上加<code>synchronized</code>关键字，效率较低</li><li><code>StringBuilder</code>可变的字符串，非线程安全，效率较高</li></ul><p>相同点：</p><ul><li>都实现了<code>CharSequence</code>接口</li><li>底层使用<code>char[]</code>存储字符串</li></ul><p>构造方法：</p><ul><li><code>String</code>:</li><li><code>String str = new String(String str);</code>根据输入内容创建不可变的字符串对象</li><li><code>String str = &quot;str&quot;;</code>直接根据字符串的值创建不可变的字符串对象</li><li><code>StringBuffer</code>:<ul><li><code>StringBuffer str = new StringBuffer(String str)</code>根据字符串的内容，来创建可变字符串对象</li><li><code>StringBuffer str = new StringBuffer()</code>创建一个空白的可变字符串对象</li></ul></li><li><code>StringBuilder</code><ul><li><code>StringBuffer str = new StringBuffer(String str)</code>根据字符串的内容，来创建可变字符串对象</li><li><code>StringBuffer str = new StringBuffer()</code>创建一个空白的可变字符串对象</li></ul></li></ul><p><strong>应该怎么选择</strong>：在执行效率方面，<code>StringBuilder</code>最高，<code>Stringbuffer</code>其次，<code>String</code>最低。</p><ul><li>当可以确定字符是不需要改变的或者修改的次数很少那么选择<code>String</code></li><li>如果需要频繁的对字符串进行修改，那么从<code>StringBuffer</code>或者<code>StringBuilder</code>中选择</li><li>优先选择<code>StringBuilder</code>，因为其效率最高，但是当需要保证线程安全时，就要选择<code>StringBuffer</code></li><li>当大致知道整个字符串长度的时候，那么就可以使用<code>StringBuilder</code>带参数的构造参数，就会在构造对象的时候创建指定长度的数组，避免不断扩容导致的底层数组不断复制</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基本数据类型</title>
    <link href="/2022/09/11/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/09/11/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h1><h2 id="Java中的八种基本类型"><a href="#Java中的八种基本类型" class="headerlink" title="Java中的八种基本类型"></a>Java中的八种基本类型</h2><table><thead><tr><th>类型</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>long</td><td>8</td><td>0L</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>8</td><td>0.0d</td></tr><tr><td>char</td><td>2</td><td>false</td></tr><tr><td>boolean</td><td>1或者4</td><td>\u0000</td></tr></tbody></table><p>  <strong>注：</strong>《Java虚拟机规范》指出boolean当作int处理4个字节，和 boolean 数组当作byte数组处理 1 个字节，具体还要看虚拟机实现是否按照规范来，所以 1 个字节、4 个字节都是有可能的。</p><h2 id="数据的类型转换"><a href="#数据的类型转换" class="headerlink" title="数据的类型转换"></a>数据的类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><h4 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h4><p>Java中不能隐式执行向下转型，因为这会使数据表示精度降低，但是可以向上转型，并且遵循以下规则：</p><ul><li>整型、常量、浮点型、字符型数据可以混合运算。</li><li>运算中，不同类型的数据先转换为同一类型，然后进行运算。</li><li>转换等级数据精度由低到高。</li><li>转换等级由低到高：byte，short，char-&gt;int-&gt;long-&gt;float-&gt;double</li></ul><h4 id="表达式数据类型自动提升"><a href="#表达式数据类型自动提升" class="headerlink" title="表达式数据类型自动提升"></a>表达式数据类型自动提升</h4><p>表达式的数据类型自动提升，关于类型的自动提升，注意下面的规则：</p><ul><li>所有的byte、short、char类型的值被提升为int</li><li>如果有一个操作数是long，计算结果是long。</li><li>如果有一个操作数是float，计算结果是float。</li><li>如果有一个操作数是double，计算结果是double。</li></ul><p><strong>注：</strong> 以上规则当存在多个数据类型根据将转换成等级最高的数据类型。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将范围大的数据转换为小数据时，可以使用强制类型转换，这种转换可能会导致溢出或者精度下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)i;<span class="hljs-comment">//强制类型转换为byte</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h3><ul><li>整数的默认类型是int。</li><li>浮点型默认是double，在定义float类型必须在数字后面跟上F或者f。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用数据类型：类，接口，数组都是引用数据类型。</p><p>引用类型的特点：</p><ul><li>引用类型作为类首先继承Object，拥有了Object类的方法。</li><li>引用类型的变量可以存储null值。</li></ul><p>Java中的基本数据类型都有对应的包装类。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>Java为包装类做了一些特殊功能：</p><ul><li><p>可以把基本数据类型的转换成字符串类型的值</p><ol><li>调用对应<strong>包装类实体</strong>.toString()方法，如<code>Integer i = 1;String s = i.toString();</code></li><li>调用对应的<strong>包装类型</strong>.toString(基本数据类型的值)，如<code>String s = Integer.toString(1);</code></li><li>直接把基本数据类型拼接字符串，如<code>int i = 0; String s = i+&quot;&quot;;</code></li></ol></li><li><p>可以把字符串类型的数值转换成对应的基本数据类型的值</p><ol><li><strong>包装类型</strong>.parse<strong>对应类型</strong>(“字符串的值”)，如<code>Integer.parseInt(&quot;1&quot;);</code></li><li><strong>包装类型</strong>.valueOf(“字符串的值”)，如<code>Integer.valueOf(&quot;1&quot;);</code></li></ol></li></ul><h3 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h3><ul><li><p>有了基本数据类型，为为什么还要包装类型？</p><blockquote><p>引用类型封装了数据和处理该数据的方法</p><p>Java中大部分类和方法都是针对引用数据类型，包括泛型和集合。</p><p>基本类型有默认值，无法表示空null。</p></blockquote></li><li><p>引用类型包括了基本类型的功能，为什么还用基本类型？</p><blockquote><p>引用类型的对象要多存储对象头，对基本类型来说空间浪费率太高。逻辑上讲，Java只要包装类就够了，但是为了运行速度，需要用到基本数据类型；优先考虑运行效率问题，所以二者同时存在是合乎情理的。</p></blockquote></li><li><p>&#x3D;&#x3D;</p><blockquote><p>基本类型：比较的是具体的值</p><p>引用类型：比较的是对象的地址</p></blockquote></li></ul><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><blockquote><p>Java是一门面向对象的编程语言，所以除了8大基础类型之外一切皆为对象，但为了方便面向对象开发，基础类型也有对应的包装类。但包装类和基础类型在赋值或比较时要进行类型转换，使用起来不够丝滑，感觉他们之间有很大的鸿沟。所以jdk1.5之后就推出了自动装箱和自动拆箱机制，使卡覅更加方便，代码更加简洁。</p><p>自动装箱就是在编译时自动将基础类型转换与之对应的包装类，而拆箱刚好与之相反，就是在编译时自动将包装类转换为与之对应的基础类型。</p></blockquote><p>自动装箱拆箱要点：</p><ul><li>自动装箱时编译器调用<code>valueOf</code>将基本类型转换成对象，同时自动拆箱时，编译器通过调用类似<code>intValue()</code> 、<code>doubleValue()</code>等这类的方法将对象转换成基本类型。</li></ul><h4 id="何时自动装箱和拆箱"><a href="#何时自动装箱和拆箱" class="headerlink" title="何时自动装箱和拆箱"></a>何时自动装箱和拆箱</h4><p>自动装箱和拆箱在Java中很常见，比如有一个方法，接受一个对象类型的参数，如果我们传入一个基本类型，那么Java会自动将这个基本类型的值转换成与之对应的包装类型。</p><p>以下两种情况会发生自动装箱</p><ul><li>基本类型作为参数传递给相应的包装类型方法</li><li>基本类型分配到对应的包装类型变量</li></ul><p>以下四种情况会发生自动拆箱：</p><ul><li>包装类型作为参数传递给基本类型的方法</li><li>包装类型分配到基本类型的变量</li><li>在进行+,-时也会发生自动拆箱，因为Integer或者其他包装类型对象无法使用运算符。</li><li>在使用三目运算符的情况下，可能会发生自动拆箱。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//自动装箱</span><br>list.add(<span class="hljs-number">2</span>);<span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure><h4 id="自动装箱和自动拆箱的优缺点"><a href="#自动装箱和自动拆箱的优缺点" class="headerlink" title="自动装箱和自动拆箱的优缺点"></a>自动装箱和自动拆箱的优缺点</h4><p><strong>优点:</strong></p><ul><li>自动拆箱和自动装箱的引入方便了我们编写程序，提高编程效率</li></ul><p><strong>缺点:</strong></p><ul><li>由于包装类型是对象，可能存在空指针异常</li><li>自动拆箱会消耗性能，在性能敏感且操作数量大的情况下，性能会明显下降</li></ul><p><strong>所以建议要避免无意义的拆箱、装箱。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2022/09/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/09/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>欢迎来到Lyice’s的博客</p><h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>本人从2017年底开始实习到现在已经工作好几年了，但是发现自己主要是在写一些偏业务上的代码。期间也跟着视频或者文章学过一些新的技术栈，但是一般都是跟着视频实践，没有真正应用到项目中。加上看过之后长时间用不到，感觉学了没多久就忘记了。所以一直想写一个博客记录下来，但是基于各种原因一直拖延到现在。加上之前想着多写几篇一起发，但是电脑坏了重装系统后写的文章都没了，所以改变了一下思路，想着每写一个文章就发一篇。</p><p>同时写博客也是达到一个自我驱动的目的，本人平时就是间接性踌躇满志，持续性混吃等死的状态。所以也希望通过写博客能让自己坚持持续的学习。</p><p>最后我并未将此地址告知任何人，也暂时不打算这么做。</p><h2 id="当下情况"><a href="#当下情况" class="headerlink" title="当下情况"></a>当下情况</h2><p>目前的技术足够应付日常的开发情况，但是想要更进一步写出简单易懂、效率高、拓展性好的代码还是比较吃力。加上国内的就业形势，为了以后不被优化，计划利用每周空闲时间来给自己充电学习。持续的提高自己的不可替代性。</p><h2 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h2><ul><li>从java基础开始梳理一下，然后通过博客记录下来</li><li>梳理完java基础之后重点看下java并发</li><li>在不加班的情况下保持周更博客</li></ul><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><p>争取通过自己的努力进一个自研、不加班的公司。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><blockquote><p> <strong>种一棵树最好的时间是十年前，其次是现在</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/08/hello-world/"/>
    <url>/2022/09/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
