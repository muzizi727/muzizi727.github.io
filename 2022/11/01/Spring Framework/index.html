

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lyice">
  <meta name="keywords" content="">
  
    <meta name="description" content="Spring Framework简介Spring Framework通常我们称它为Spring框架。 Spring框架是一个分层的、面向切面的Java应用程序的一站式轻量级解决方案，它是Spring技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。 Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发抽取出来的框架，因此它">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Framework">
<meta property="og:url" content="http://example.com/2022/11/01/Spring%20Framework/index.html">
<meta property="og:site_name" content="Lyice&#39;s Blog">
<meta property="og:description" content="Spring Framework简介Spring Framework通常我们称它为Spring框架。 Spring框架是一个分层的、面向切面的Java应用程序的一站式轻量级解决方案，它是Spring技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。 Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发抽取出来的框架，因此它">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover.jpg">
<meta property="article:published_time" content="2022-11-01T12:16:33.000Z">
<meta property="article:modified_time" content="2023-03-24T12:58:40.572Z">
<meta property="article:author" content="Lyice">
<meta property="article:tag" content="Java框架">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/cover.jpg">
  
  
  
  <title>Spring Framework - Lyice&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lyice&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/index.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Spring Framework"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-01 20:16" pubdate>
          2022年11月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          149 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring Framework</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Framework通常我们称它为Spring框架。</p>
<p>Spring框架是一个分层的、面向切面的<code>Java</code>应用程序的一站式轻量级解决方案，它是Spring技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。</p>
<p>Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>
<p>Spring总结起来优点如下：</p>
<ul>
<li>低侵入设计，代码的污染极低。</li>
<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Wirte Once，Run Anywhere的承诺。</li>
<li>Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>Spring的AOP支持将一些通用任务如安全、事务、日志等进行集中式管理，从而提供更好的复用。</li>
<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。</li>
<li>Spring的高度开放性，并不强制应用完成依赖于Spring，开发者可以自由选择用Spring框架的部分或者全部。</li>
</ul>
<p>Spring框架的组成结构图如下所示：</p>
<p>![spring-overview](img&#x2F;Spring Framework.assets&#x2F;673670c9a34075831373b711cb8f21b7.png)</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/basic-knowledge-summary-of-spring.html">Spring基础知识汇总 Java开发必看 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>IoC全称为Inversion of Control，也叫“控制反转”，它不是一门技术，而是一种设计思想。</p>
<p>Spring通过IoC容器来管理所有<code>Java</code>对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由IoC容器管理的<code>Java</code>对象称为Spring Bean，它与使用关键字<code>new</code>创建的<code>Java</code>对象没有任何区别。</p>
<p>IoC容器是Spring框架中最重要的核心组件之一，它贯穿了Spring从诞生到成长的整个过程。</p>
<h3 id="IoC容器介绍"><a href="#IoC容器介绍" class="headerlink" title="IoC容器介绍"></a>IoC容器介绍</h3><p>Spring 通过一个配置文件描述Bean及Bean之间的依赖关系，利用<code>Java</code>语言的反射功能实现实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、生命周期管理、Bean实例代理、时间发布、资源装载等高级服务。</p>
<p>Spring提供了IoC容器实现的两种方式（两个接口）：</p>
<ol>
<li>BeanFactory：IoC容器基本实现，是Spring内部的使用接口，面向Spring本身</li>
<li>ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，面向使用Spring框架的开发者，几乎所有的应用场合我们都直接使用ApplicationContext而非底层的BeanFactory</li>
</ol>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory是Spring IoC中最核心的接口，它承担IoC最基本的职责，即创建并管理各种类的对象。BeanFactory接口的关键方法getBean的实现中，会试图从缓存中查找并返回对应的Bean。若不存在，则根据Bean对应的bean definition来创建bean对象（包括实例化、属性赋值、依赖装配、初始化等工作），因此得名Bean工厂。</p>
<p>容器启动时，BeanFactory会从配置元信息中加载beanDefinition，之后Bean的创建和管理都依赖于beanDefinition。</p>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>ApplicationContext容器是BeanFactory的子接口，也被称为spring上下文。</p>
<p>ApplicationContext 是Spring中较高级的容器。和BeanFactory类似，它可以加载配置文件中定义的bean，将所有的bean集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。</p>
<p>在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现。</p>
<h4 id="容器总结"><a href="#容器总结" class="headerlink" title="容器总结"></a>容器总结</h4><ul>
<li>BeanFactory是IoC容器的顶层接口，初始化BeanFactoyr对象时，加载的bean延迟加载</li>
<li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li>
<li>ApplicationContexti接口提供基础的bean操作相关方法，通过其他接口拓展其功能</li>
<li>ApplicationContext接口常用初始化类<ul>
<li>ClassPathXmlApplicationContext：该容器从XML文件中加载被定义的bean。默认加载项目的CLASSPATH路径下的配置文件。</li>
<li>FileSystemXmlApplicationContext：该容器从XML文件中加载被定义的bean。需要提供给构造XML文件的完整路径。</li>
<li>WebXmlApplicationContext：该容器会在一个web应用程序的范围内加载在XML文件中被定义的bean。</li>
</ul>
</li>
</ul>
<h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Spring bean是Spring框架在运行时管理的对象。Spring bean是任何Spring应用程序的基础。</p>
<p>在XML配置的<code>&lt;bean&gt;</code>标签中可以包含多个属性或子元素，常用的属性或子元素如下：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bean的唯一标识，IoC容器对bean的配置和管理通过该属性完成。</td>
</tr>
<tr>
<td>name</td>
<td>bean的名称，可以通过name属性为一个bean指定多个名称，每个名称之间用逗号、分号或空格隔开，IoC容器也可以通过name属性配置和管理容器中的bean</td>
</tr>
<tr>
<td>class</td>
<td>这个属性是必须的，用来指定bean的具体实现类，它必须是一个完整的类名，即类的全限定名。</td>
</tr>
<tr>
<td>autowire</td>
<td>自动装配模式</td>
</tr>
<tr>
<td>scope</td>
<td>表示bean的作用域，默认为singleton。</td>
</tr>
<tr>
<td>constructor-arg</td>
<td><code>&lt;bean&gt;</code>标签的子标签，可以通过该属性将构造参数传入以实现bean的实例化。</td>
</tr>
<tr>
<td>property</td>
<td><code>&lt;bean&gt;</code>标签的子标签，用于调用bean实例的<code>setter</code>方法对属性进行赋值，聪儿完成属性的注入。该元素的name属性用于指定bean实例中相应的属性名。</td>
</tr>
<tr>
<td>ref</td>
<td><code>&lt;constructor&gt;</code>和<code>&lt;property&gt;</code>等标签的子标签，用于指定bean实例的引用，即<code>&lt;bean&gt;</code>标签中的id或name属性。</td>
</tr>
<tr>
<td>value</td>
<td><code>&lt;constructor&gt;</code>和<code>&lt;property&gt;</code>等标签的子标签，用于指定一个常量值。</td>
</tr>
<tr>
<td>list</td>
<td>用于bean实例的List或数组类型的属性注入。</td>
</tr>
<tr>
<td>set</td>
<td>用于bean实例的Set类型的属性注入。</td>
</tr>
<tr>
<td>map</td>
<td>用于bean实例的Map类型的属性注入。</td>
</tr>
<tr>
<td>entry</td>
<td><code>&lt;map&gt;</code>标签的子标签，用于设置一个键值对。其中key属性指定map的key，ref或value指定其值。</td>
</tr>
<tr>
<td>init-method</td>
<td>容器初始化bean时调用该方法</td>
</tr>
<tr>
<td>destroy-method</td>
<td>容器删除bean时调用该方法，该方法只在作用域为singleton时有效</td>
</tr>
<tr>
<td>lazy-init</td>
<td>懒加载，为true时容器在首次请求时才会创建bean实例；false时容器启动时创建bean实例。该方法只在作用域为singleton时有效</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.StudentFactory&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;factory&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student student2&quot;</span> //<span class="hljs-attr">多个可以用空格</span>、<span class="hljs-attr">逗号或</span>；</span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.Student&quot;</span> //<span class="hljs-attr">bean的具体实现</span></span><br><span class="hljs-tag">      <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>  //<span class="hljs-attr">懒加载</span></span><br><span class="hljs-tag">      <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span>  //<span class="hljs-attr">初始时调用的方法</span></span><br><span class="hljs-tag">      <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span> //<span class="hljs-attr">bean销毁时调用的方法</span></span><br><span class="hljs-tag">      <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;factory&quot;</span> //<span class="hljs-attr">实例工厂</span>，<span class="hljs-attr">需要提前加载到IoC容器中</span></span><br><span class="hljs-tag">      <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span> //<span class="hljs-attr">bean工厂方法</span></span><br><span class="hljs-tag">      <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>  //<span class="hljs-attr">作用域</span></span><br><span class="hljs-tag">      &gt;</span><br>    //name代表bean的属性名，ref表示IoC容器加载bean的name或id<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;studentDao dao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.StudentDao&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>自动装配，它们可以用于指示Spring容器未来使用自动装配进行依赖注入。Spring提供了五种自动装配规则，它们分别对应autowire的5个值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>默认值，表示不使用自动装配，bean的依赖关系必须通过<code>&lt;constructor-agrg&gt;</code>和<code>&lt;property&gt;</code>标签的ref属性来定义。</td>
</tr>
<tr>
<td>byName</td>
<td>按名称自动装配：Spring会根据Java类中对象属性的名称在IoC容器中查找，若某个bean的id或name属性值与属性值的名称相同，则获取这个bean并与当前的Java类的bean建立关联关系。</td>
</tr>
<tr>
<td>byType</td>
<td>按类型自动装配：Spring会根据Java类中对象属性的类型在IoC容器中查找，若某个bean的class属性值与这个对象属性的类型相匹配，则获取这个bean并与当前的Java类的bean建立关联关系。</td>
</tr>
<tr>
<td>default</td>
<td>表示默认采用上一级标签<code>&lt;beans&gt;</code>设置的自动装配规则(default-autowire)进行装配。</td>
</tr>
<tr>
<td>constructor</td>
<td>与byType类似，不同之处在于它应用于构造器参数，如果容器中没有找到与构造器参数类型一致的bean则抛出异常。</td>
</tr>
</tbody></table>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>当通过Spring容器创建一个bean实例时，不仅可以完成bean实例的实例化，还可以为bean指定特定的作用域。Spring支持如下五种作用域：</p>
<ol>
<li>singleton：单例模式，在IoC容器中，singleton作用域的bean只会生成一个实例。</li>
<li>prototype：每次通过容器的<code>getBean()</code>方法获取prototype作用域的bean，都会产生一个新的bean实例。</li>
<li>request：对于一次http请求，request作用域的bean只生成一个实例。只有在Web应用中使用Spring时，该作用域才生效。</li>
<li>session：该作用域将bean的定义限制为http会话，只在Web应用的上下文中有效。</li>
<li>global session：每个全局的http session对应一个bean实例。同样只在Web应用中有效。</li>
</ol>
<p><strong>如果不指定bean的作用域，Spring默认使用singleton作用域。prototype作用域的bean的创建、销毁代价比较大；而singleton作用域的bean实例一旦创建就可以重复使用。因此应尽量避免将bean设置成prototype作用域。</strong></p>
<p><strong>剩下的作用域只能基于Web的ApplicationContext实现中（例如XmlWebApplicationContext）才能使用，否则就会抛出一个IllegalStateException的异常。</strong></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>对于普通的<code>Java</code>对象，当<code>new</code>的时候创建对象，然后该对象就可以使用了。一旦该对象不再被使用，则由<code>Java</code>垃圾回收器进行回收。</p>
<p>而Spring中的对象是bean，bean和普通的<code>Java</code>对象没有什么大的区别，只不过Spring不需要再自己去<code>new</code>对象了，而是由IoC容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去找IoC容器即可。IoC其实就是解决对象之间的耦合问题，bean的生命周期完全由容器控制。</p>
<p>详细的流程如下：</p>
<p>![bean生命周期](img&#x2F;Spring Framework.assets&#x2F;image-20221116210721982.png)</p>
<p>单实例bean的全生命周期具体包含一下部分：</p>
<ol>
<li>BeanDefinition部分<ul>
<li>BeanDefinition的解析</li>
<li>BeanDefinition的注册</li>
</ul>
</li>
<li>bean实例部分<ol>
<li>bean的实例化：实例化一个bean</li>
<li>bean的属性赋值：为bean设置相关属性和依赖</li>
<li>bean的初始化： 执行bean相对应的初始化方法</li>
<li>bean的使用：当bean初始化之后才能被用户使用</li>
<li>bean的销毁：执行bean相对应的销毁方法</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码位于 AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = (BeanWrapper)<span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>    	<span class="hljs-comment">// 实例化阶段</span><br>        instanceWrapper = <span class="hljs-built_in">this</span>.createBeanInstance(beanName, mbd, args);<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>    	<span class="hljs-comment">// 属性赋值阶段</span><br>        <span class="hljs-built_in">this</span>.populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 初始化阶段</span><br>        exposedObject = <span class="hljs-built_in">this</span>.initializeBean(beanName, exposedObject, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>        ...<br>    &#125;<br><br>    ...<br>        <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//销毁-注册回调接口</span><br>         <span class="hljs-built_in">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>         <span class="hljs-keyword">return</span> exposedObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面为bean的主要生命周期，Spring为了方便扩展预留了许多钩子函数。当我们需要对bean进行修改时，只需要实现对应的接口，覆盖相对应的方法即可，当调用<code>initializeBean</code>时会对这些接口进行判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码位于 AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-comment">//回调Aware接口的方法（BeanNameAware,BeanClassLoaderAware,BeanFactoryAware）</span><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>        AccessController.doPrivileged(() -&gt; &#123;<br>            <span class="hljs-built_in">this</span>.invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;, <span class="hljs-built_in">this</span>.getAccessControlContext());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.invokeAwareMethods(beanName, bean);<br>    &#125;<br>    <br>    <span class="hljs-comment">//BeanPostProceesor前置处理</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = <span class="hljs-built_in">this</span>.applyBeanPostProcessorsBeforeInitialization(bean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//bean的初始化方法（init-method、afterPropertiesSet）</span><br>        <span class="hljs-built_in">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var6) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>, beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, var6);<br>    &#125;<br>	<span class="hljs-comment">//BeanPostProceesor后置处理</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = <span class="hljs-built_in">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>![bean的部分](img&#x2F;Spring Framework.assets&#x2F;20210710134349143.png)</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/118500805">一文读懂 Spring Bean 的生命周期_老周聊架构的博客-CSDN博客_springbean生命周期详解</a></p>
<h3 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h3><h4 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h4><p>循环依赖其实就是循环引用，也就是两个或两个以上的bean互相引用对方，最终形成闭环。</p>
<p>![循环依赖](img&#x2F;Spring Framework.assets&#x2F;image-20221124205701883.png)</p>
<p>代码中的表现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Componet</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Spring的循环依赖过程，跟bean的声明周期密切相关，在实例化bean的时候，会完成依赖注入。所以就会出现<code>实例化A</code>-&gt;<code>属性填充注入B</code>-&gt;<code>B没有实例化，需要先实例化B</code>-&gt;<code>实例化B</code>-&gt;<code>属性填充注入A</code>-&gt;<code>A实例化未完成，无法注入</code>-&gt;<code>实例化B失败</code>-&gt;<code>实例化A失败</code>。 </p>
<h4 id="Spring解决循环依赖的方式"><a href="#Spring解决循环依赖的方式" class="headerlink" title="Spring解决循环依赖的方式"></a>Spring解决循环依赖的方式</h4><p>Spring是通过三级缓存来解决循环依赖的，提前暴露的对象存放在三级缓存中，二级缓存存放过度bean，一级缓存存放最终形成的bean。</p>
<p>![三级缓存](img&#x2F;Spring Framework.assets&#x2F;下载.png)</p>
<p><code>ObjectFactory</code>是一个函数式接口：</p>
<p>在<code>java</code>中，方法在调用的时候都是具体的值，当使用函数式接口作为方法的参数类型时，可以将一个lambda表达式作为参数传递到方法中，lambda表达式在方法执行的时候并不会立刻调用，只有在调用<code>getObject</code>方法的时候才会完成此表达式的调用。</p>
<p>![三级缓存过程](img&#x2F;Spring Framework.assets&#x2F;image-20221124210201570.png)</p>
<p>为什么必须要使用三级缓存来解决循环依赖问题？三级缓存是如何解决循环依赖问题的？</p>
<ol>
<li><p>创建代理对象的时候是否需要创建原始对象？<br>需要，因为bean的生命周期是固定的，每次在对象创建的时候必须要先创建出原始对象</p>
</li>
<li><p>同一个容器中能同时存在同名的不同对象吗？<br>不能</p>
</li>
<li><p>如果同时存在了原始对象和代理对象，怎么办?<br>当对外暴露的时候应该使用代理对象，覆盖原始对象</p>
</li>
<li><p>为什么加了一个三级缓存就可以解决这个问题？<br>在整个bean的生命周期中，bean对象的属性赋值（populateBean）在前执行，而bean动态代理对象（BeanPostProcessor的后置处理方法）的创建在后执行，</p>
</li>
</ol>
<p><strong>按照正常的流程，先进行对象属性的赋值，而对象属性的赋值过程引用的都是原始对象，当赋值完成之后才会进行代理对象的创建，那么此时引用的对象必然不是最终版本的bean对象</strong></p>
<ol start="5">
<li><p>如果想解决这个问题的话，怎么办？<br>需要将代理对象的创建过程前置，也就是说在进行对象的属性赋值的时候，在设置具体的值之前，必须要唯一性的确定出到底是代理对象还是原始对象</p>
</li>
<li><p>为什么要用lambda表达式呢？<br>因为在方法调用的时候lambda表达式并不会立刻执行，在设置值具体确定的前一个步骤，回调即可，就可以唯一性的确定好是用代理对象还是原始对象了</p>
</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP 面向切片编程： AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块之间的耦合度，利于以后项目的拓展与维护。</p>
<p>使用AOP我们可以把一些通用功能抽取出来，在需要调用的地方直接调用即可，这样大大简化了代码量，提高了系统的扩展性。 </p>
<h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>关于面向切面编程的一些术语：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>切面（Aspect）</td>
<td>切面是通知和切点的结合</td>
</tr>
<tr>
<td>连接点（Joint Point）</td>
<td>连接点表示应用执行过程中能够插入切面的一个点</td>
</tr>
<tr>
<td>通知（Advice）</td>
<td>AOP中的增强处理，通知描述了切面何时执行以及如何执行增强处理</td>
</tr>
<tr>
<td>切入点（Pointcut）</td>
<td>可以插入增强处理的连接点</td>
</tr>
</tbody></table>
<p>通知（Advice）的类型：</p>
<table>
<thead>
<tr>
<th>通知类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>before</td>
<td>在目标方法执行之前运行（前置通知）</td>
</tr>
<tr>
<td>after</td>
<td>在目标方法执行之后执行（后置通知）</td>
</tr>
<tr>
<td>after-returnning</td>
<td>目标方法正常返回时执行（正常返回通知）</td>
</tr>
<tr>
<td>after-throwing</td>
<td>目标方法抛出异常时执行（异常返回通知）</td>
</tr>
<tr>
<td>around</td>
<td>在目标方法执行之前和之后执行（环绕通知）</td>
</tr>
</tbody></table>
<h3 id="AOP的实现原理"><a href="#AOP的实现原理" class="headerlink" title="AOP的实现原理"></a>AOP的实现原理</h3><p>AOP实现可以分为两类：</p>
<ol>
<li>静态AOP实现：AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。</li>
<li>动态AOP实现：AOP框架在运行阶段生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。</li>
</ol>
<p>一般来说，静态AOP实现具有较好的性能，但是需要特殊的编译器。动态AOP实现是纯Java实现，因此无需特殊的编译器，但是通常性能略差。</p>
<h4 id="AspectJ-AOP"><a href="#AspectJ-AOP" class="headerlink" title="AspectJ AOP"></a>AspectJ AOP</h4><p>AspectJ是一个基于Java语言的全功能的AOP框架，它并不是Spring的组成部分，是一款独立的AOP框架。</p>
<p>但犹豫AspectJ支持通过Spring配置AspectJ切面，因此它是Spring AOP的完美补充，通常情况下，我们都是将AspectJ和Spring框架一起使用，简化AOP操作。</p>
<p>使用AspectJ需要在Spring项目中导入Spring AOP和AspectJ相关的jar包：</p>
<ul>
<li>spring-aop-xxx.jar</li>
<li>spring-aspects-xxx.jar</li>
<li>aspectjweaver-xxxx.jar</li>
</ul>
<p>以上三个jar包中，前两个spring开头的都是Spring框架提供的jar包，而最后一个则是AspectJ提供的。</p>
<h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用jdk动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGLIB动态代理生成一个被代理对象的子类作为代理。</p>
<p>Spring AOP用到的两种动态代理技术：JDK自带的动态代理和、CGLIB库</p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理</li>
<li>CGLIB是针对类实现代理，生成指定类的一个子类，覆盖其中的方法</li>
</ul>
<p><strong>Spring AOP和AspectJ AOP的区别：</strong> Spring AOP是属于运行时增强，AspectJ AOP是编译时增强。 Spring AOP是基于代理， AspectJ AOP是基于字节码操作。 AspectJ AOP相比于Spring AOP更强大，Spring AOP相对来说更简单。如果切面比较少，两者性能差异不大。否则最好选择AspectJ 它比Spring AOP快很多。</p>
<h2 id="Spring事务相关"><a href="#Spring事务相关" class="headerlink" title="Spring事务相关"></a>Spring事务相关</h2><p>统一一致的事务抽象是Spring框架的一大优势，无论是全局事务还是本地事务，JTA、JDBC、JPA等，Spring都使用统一的编程模型，使得应用程序很容易地在全局事务与本地事务，或者不同事务框架之间进行切换。</p>
<p>Spring支持两种事务管理方式：</p>
<ol>
<li>编程式事务：通过<code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，控制回滚或者提交。</li>
<li>声明式事务：通过<code>@Transactional</code>注解声明事务，不需要额外的代码。<strong>Spring推荐的方式，非侵入式开发。</strong></li>
</ol>
<h3 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h3><p>事务属性可以理解为事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面：</p>
<ol>
<li>传播行为</li>
<li>隔离规则</li>
<li>回滚规则</li>
<li>事务超时</li>
<li>是否只读</li>
</ol>
<p>Spring框架中，事务相关的核心接口如下：</p>
<ul>
<li><code>PlatformTransactionManager</code>：事务管理器，Spring事务策略的核心</li>
<li><code>TransactionDefinition</code>：事务属性定义</li>
<li><code>TransactionStatus</code>：事务运行状态</li>
</ul>
<p>下图是Spring事务抽象的核心类图：</p>
<p>![Spring事务类图](img&#x2F;Spring Framework.assets&#x2F;v2-ff9900cb40f07db75d1190628f464564_720w.webp)</p>
<p><code>PlatfromTransactionManager</code>接口定义了三个方法用来操作事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br>    <span class="hljs-comment">//获得事务</span><br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>	<span class="hljs-comment">//提交事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>	<span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>TransactionDefinition</code>接口中定义了事务的各种信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionDefinition</span> &#123;<br>    <span class="hljs-comment">//事务传播行为</span><br>    <span class="hljs-comment">//如果当前没有事务，就新建一个事务，如果已经存在一个事务，则默认加入到这个事务中。 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//支持当前事务，如果当前没有事务，就以非事务方式执行。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_SUPPORTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_MANDATORY</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//表示当前方法必须运行在自己的事务中，以一个新的事务执行。如果当前存在事务，当前事务会被挂起。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRES_NEW</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//表示该方法不运行在事务中。如果当前存在事务，当前事务会被挂起。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NOT_SUPPORTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//表示当前方法从来不在事务中执行，如果当前存在事务，则会抛出异常。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NEVER</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//如果存在当前事务，则嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NESTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <br>    <span class="hljs-comment">//事务隔离级别</span><br>    <span class="hljs-comment">//使用后端数据库默认的隔离级别</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//允许读未提交的数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_UNCOMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//允许读已经提交的数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//允许读取并发事务已经提交的事务</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_REPEATABLE_READ</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//最高的隔离级别，也是最慢的隔离级别。事务一个一个串行执行。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_SERIALIZABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//返回事务的传播行为</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPropagationBehavior</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIsolationLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>	<span class="hljs-comment">//返回事务的超时时间，如果超过该时间限制但事务还没有完成则自动回滚事务</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTimeout</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>	<span class="hljs-comment">//返回是否未只读事务</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//事务名称</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> TransactionDefinition <span class="hljs-title function_">withDefaults</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StaticTransactionDefinition.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>TransactionStatus</code>接口内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransactionExecution</span>, SavepointManager, Flushable &#123;<br>    <span class="hljs-comment">//判断是否有回滚点</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasSavepoint</span><span class="hljs-params">()</span>;<br>	<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionExecution</span> &#123;<br>    <span class="hljs-comment">//是否是一个新的事务</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNewTransaction</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//设置只能被回滚</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRollbackOnly</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//是否只能回滚</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRollbackOnly</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//是否已完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCompleted</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SavepointManager</span> &#123;<br>    <span class="hljs-comment">//创建回滚点</span><br>    Object <span class="hljs-title function_">createSavepoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TransactionException;<br>	<span class="hljs-comment">//回滚到回滚点</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackToSavepoint</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>	<span class="hljs-comment">//释放回滚点</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseSavepoint</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h4><p>事务回滚规则定义了哪些异常会导致事务回滚；哪些不会。默认情况下，只有在运行时异常（RuntimeException）和错误（Error）会导致事务回滚。而在遇到检查异常（Checked）不会回滚。但是你可以声明事务在遇到哪些特定的检查型异常时回滚；同样你也可以声明事务遇到特定的异常不会滚，即使这些异常是运行期异常。</p>
<h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>为了应用程序很好的运行，事务不能运行太长时间。所谓事务超时，就是指一个事务所运行的最长时间，如果超过该时间限制但是事务还没有完成，则自动回滚事务。在<code>TransactionDefinition</code>中以<code>int</code>表示，其单位是秒，默认值为-1。</p>
<h4 id="是否只读"><a href="#是否只读" class="headerlink" title="是否只读"></a>是否只读</h4><p>如果一个事务中所有关于数据库的操作都是只读的，也就是说这些操作并不修改数据。这个时候我们应该给该事务设置只读属性，这样可以帮助数据库引擎优化事务，提升效率。</p>
<h3 id="Spring事务的两种实现方法"><a href="#Spring事务的两种实现方法" class="headerlink" title="Spring事务的两种实现方法"></a>Spring事务的两种实现方法</h3><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><p>通过<code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，控制事务提交或者回滚，实际应用中很少使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>PlatformTransactionManager manager;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransactionManager</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> manager.getTransaction(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>());<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//处理业务</span><br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">//处理完成</span><br>        manager.commit(status);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">//业务异常</span><br>        manager.rollback(status);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>底层建立在AOP的基础上，在方法执行前后进行拦截，并且在目标方法开始执行前创建新事务或加入一个已存在的事务，最后在目标方法执行后根据情况提交或回滚事务。声明事务优点代码侵入性最小，推荐使用。只需要在目标方法上添加<code>@Transactional</code>注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransaction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//处理业务</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Transactional注解使用详情"><a href="#Transactional注解使用详情" class="headerlink" title="@Transactional注解使用详情"></a><code>@Transactional</code>注解使用详情</h4><h5 id="Transactional的作用范围"><a href="#Transactional的作用范围" class="headerlink" title="@Transactional的作用范围"></a><code>@Transactional</code>的作用范围</h5><ol>
<li>类：如果这个注解使用在类上的，类里所有的<code>public</code>方法都生效</li>
<li>接口：所有方法都生效，不推荐在接口上使用</li>
<li>方法：推荐将注解用于方法上，<strong>不过该注解只能应用到<code>public</code>的方法上，否则不生效</strong></li>
</ol>
<p><strong>为什么建议直接加在方法上：因为<code>@Transactional</code>如果直接加在类或者接口上，此注解会对当前类下所有<code>public</code>的方法都生效：第一影响性能，有些方法可能不需要事务，第二方法不同可能<code>@Transactional</code>所需要的配置也不同，比如有些查询的方法需要配置<code>readOnly</code>参数，没办法单独配置。所以强烈建议<code>@Transactional</code>加到方法上。</strong></p>
<h5 id="Transactional的常用配置参数"><a href="#Transactional的常用配置参数" class="headerlink" title="@Transactional的常用配置参数"></a><code>@Transactional</code>的常用配置参数</h5><p><code>@Transactional</code>注解里各个属性和上面的事务属性是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional &#123;<br>    <span class="hljs-comment">//当配置文件中有多个TransactionManager，可以用该属性指定选择哪个事务管理器</span><br>    <span class="hljs-meta">@AliasFor(&quot;transactionManager&quot;)</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String <span class="hljs-title function_">transactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">//事务标签</span><br>    String[] label() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">//事务的传播行为，默认值采用REQUIRED</span><br>    Propagation <span class="hljs-title function_">propagation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Propagation.REQUIRED;<br><br>    <span class="hljs-comment">//事务的隔离规则，默认采用DEFAULT</span><br>    Isolation <span class="hljs-title function_">isolation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Isolation.DEFAULT;<br><br>    <span class="hljs-comment">//事务超时时间</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//事务的超时时间</span><br>    String <span class="hljs-title function_">timeoutString</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">//是否只读事务</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">readOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//用于指定能够触发事务回滚的异常类型</span><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] rollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    <br>	<span class="hljs-comment">//用于指定能够触发事务回滚的类名</span><br>    String[] rollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">//用于指定不会触发事务回滚的异常类型</span><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] noRollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">//用于指定不会触发事务回滚的类名</span><br>    String[] noRollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><p>SPI全称Service Provider Interface，<strong>是一种组件发现和注册的方式，它可以用来启用框架扩展和替换组件。</strong></p>
<p><code>Java</code>提供一套用来被第三方实现或扩展的接口，<strong>SPI的作用就是为这些被扩展的API寻找服务实现</strong>。本质是通过<strong>基于接口的编程+策略模式+配置文件</strong>实现动态加载。可以实现<strong>解耦</strong>，提高框架的<strong>可扩展性</strong>。</p>
<p>很多框架都用了SPI机制，比如：Spring框架，JDBC、日志接口等。</p>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><h5 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataBaseSPI</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connection</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h5><p>mysql：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MysqlDataBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataBaseSPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connection</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;mysql database 已经链接。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>oracle：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OracleDataBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataBaseSPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connection</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;oracle database 已经链接。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在resource下的META-INF目录新增spring.factories文件</p>
<p>![image-20230308124750629](img&#x2F;Spring Framework.assets&#x2F;image-20230308124750629.png)</p>
<p>spring.factories文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs factories">org.example.DataBaseSPI = org.example.MysqlDataBase,org.example.OracleDataBase<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;DataBaseSPI&gt; dataBaseSPIS = SpringFactoriesLoader.loadFactories(DataBaseSPI.class, Thread.currentThread().getContextClassLoader());<br>        <br>        <span class="hljs-keyword">for</span> (DataBaseSPI dataBaseSPI : dataBaseSPIS) &#123;<br>            dataBaseSPI.connection();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql <span class="hljs-keyword">database</span> 已经链接。。。<br>oracle <span class="hljs-keyword">database</span> 已经链接。。。<br></code></pre></td></tr></table></figure>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">loadFactories</span><span class="hljs-params">(Class&lt;T&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    Assert.notNull(factoryType, <span class="hljs-string">&quot;&#x27;factoryType&#x27; must not be null&quot;</span>);<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> classLoader;<br>    <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//若没有传入类加载器，使用默认的类加载器</span><br>        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<br>    &#125;<br>	<span class="hljs-comment">//获取指定工厂名称列表</span><br>    List&lt;String&gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);<br>    <span class="hljs-comment">//如果记录器Trace跟踪激活，将工厂名称列表输出</span><br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Loaded [&quot;</span> + factoryType.getName() + <span class="hljs-string">&quot;] names: &quot;</span> + factoryImplementationNames);<br>    &#125;<br>	<span class="hljs-comment">//创建结果集</span><br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(factoryImplementationNames.size());<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> factoryImplementationNames.iterator();<br>	<span class="hljs-comment">//实例化工厂类，并添加到结果集中</span><br>    <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">factoryImplementationName</span> <span class="hljs-operator">=</span> (String)var5.next();<br>        result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));<br>    &#125;<br>	<span class="hljs-comment">//对结果集列表进行排序</span><br>    AnnotationAwareOrderComparator.sort(result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大致工作流程如下：</p>
<ol>
<li>通过classLoader去加载工厂获取对应类名称，如果未指定类加载器，则使用默认的；</li>
<li>通过<code>instantiateFactory</code>方法实例化工厂类，并添加到结果集中；</li>
<li>对结果集进行排序，然后返回结果集</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java%E6%A1%86%E6%9E%B6/">#Java框架</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Spring Framework</div>
      <div>http://example.com/2022/11/01/Spring Framework/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lyice</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/07/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/" title="Java集合之Map">
                        <span class="hidden-mobile">Java集合之Map</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
<div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
